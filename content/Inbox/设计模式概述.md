---
title: '设计模式概述'
categories: ''
description: ''
order: 0
date: 2024-07
---

## UML 类图

> [!quote] 参考:
> - [Sparx Systems - UML 2 教程l - 类图](https://sparxsystems.cn/resources/uml2_tutorial/uml2_classdiagram.html)
> - [看懂UML类图和时序图 — Graphic Design Patterns (design-patterns.readthedocs.io)](https://design-patterns.readthedocs.io/zh-cn/latest/read_uml.html)

类定义了对象的属性和行为，是对象的静态视图。类元素之间有泛化、聚合、关联等关系。

访问修饰符：`+`、`-`、`#`、`~` 分别表示公有、私有、保护、默认 (包)。

### 泛化、实现

**泛化** (Generalizations) 表示继承的含义，使用**实线空心三角箭头**指向父类。下图表示 Circle 泛化/继承自 *Shape*，接口或抽象类名称使用斜体。  
  ![[_resources/attachment/fa6660cb-2444-4acc-ad23-dbbe6295f867.png]]  

**实现** (Realizations) 表示类和接口之间的实现关系，使用**虚线空心三角箭头**指向接口。  
  ![[_resources/attachment/6eda6cab-72ab-4c5d-988a-f3e7a3e296eb.png]]

### 聚合、组合

**聚合** (Aggregations) 表示整体和部分组成的含义，例如树木之于森林，使用**实线空心菱形箭头**表示。

**组合** (Composition) 表示整体和部分的强聚合关系，例如心脏之于人，使用**实线实心菱形箭头**表示。  
  ![[_resources/attachment/406c183f-9658-4378-bc61-7617d8ca755a.png]]

> [!attention] 聚合 vs 组合
> - 两者都体现了 "has-a" 关系，就是部分对象作为另一个整体对象的属性。
> - 在聚合中，部分对象可以属于多个整体对象 (一对一、一对多、多对多)，部分对象的生命周期不受整体对象的生命周期影响，如上图中一个联系人可以属于多个联系人组，当联系人组删除，不会有联系人删除，又例如员工之于公司。
> - 在组合中，部分对象只能属于一个整体对象 (一对一、一对多)，其生命周期完全受控于整体对象，整体对象消失时，部分对象也必须消失，如上图中联系人不能独立于地址簿存在，又例如引擎之于汽车。

### 关联、依赖

**关联** (Associations) 表示两个类元素之间的一种简单的“使用”关系，不像聚合/组合那样含有“包含”的意思，体现在代码中就是一个类的实例引用了另一个类的实例。下图表示 Team 的实例将作为 Player 中的一个名为 playsFor 的属性。  
  ![[_resources/attachment/644b1e95-94a6-480a-81ab-e69467a952f1.png]]  
关联可以具有方向，没有方向时表示 A 和 B 互相知道对方，如下图，若指明了方向则表示 A 知道 B，B 不知道 A。

![[_resources/attachment/3f7567a2-7b5a-415b-b38d-402b74543c3b.png]]

关联不一定只限于两个类之间，如下图，Role 称为关联类，表示关联连接也具有属性和行为。如下图 Employee 在不同的 Project 中扮演着不同的 Role。  

![[_resources/attachment/c66943e3-ddc5-4530-ae4f-98f96a657e11.png]]

**依赖** (Dependency) 使用虚线箭头表示，是最弱的一种关系，和关联相比意在表示运行时的、临时性的而非固定的依赖，体现在代码中就是方法参数、局部变量或静态方法调用。下图表示 A 运行过程中会用到 B，应避免双向依赖。  
  ![[_resources/attachment/f824d590-9e03-4563-8a32-15f07492696b.png]]

### 嵌套

**嵌套** (Nestings) 可以表示内部类的含义，使用下图所示的方式表示。  
  ![[_resources/attachment/412c5f16-9228-453c-9acb-df1dc72da48b.png]]

---

## 设计模式七大原则

### 单一职责原则 (Single Responsibility Principle, SRP)

一个类 (或方法、模块) 只承担单一的职责，降低耦合度，较少代码变更带来的风险。否则，当一个职责发生变化时，可能会影响其他职责。

### 开闭原则 (Open Closed Principle, OCP)

对扩展开放，对修改关闭。当模块功能发生变化时，尽量通过扩展的方式而不是修改现有代码，避免给旧代码引入错误。

### 里氏替换原则 (Liskov Substitution Principle, LSP)

所有引用基类的地方必须能透明地使用其子类的对象。即子类应尽量不要重写父类的方法，避免发生多态。这样做是为了减少父类改变带来的影响，且只有当子类可以替换基类而系统功能不受影响时，基类才能算是真正意义上的被复用。

即子类应该尽可能少的重写父类的方法，如果一个子类重写了大部分父类的方法，那应当将子类提升到与父类一个级别，通过让两者继承同一个基类，或使用组合、聚合的方法实现。

### 接口隔离原则 (Interface Segregation Principle, ISP)

类之间的依赖关系应该建立在最小的接口上，不应该依赖它不需要的接口。  
例如类 A 依赖于接口 IX 的实现类 X 中的 (a, b, c) 方法，类 B 依赖于接口 IX 的实现类 Y 中的 (d, e) 方法，则 X 和 Y 将不得不实现额外的方法，应当将接口 IX 拆分为两个接口分别包含 (a, b, c) 和 (d, e)。

### 迪米特法则 (Law of Demeter, LOD)

也称为最少知识原则 (Least Knowledge Principle, LKP)，一个对象应当对其他对象有尽可能少的了解，只和“朋友”通信，不和陌生人通信。

对象之间的耦合关系可以看作朋友关系，出现在成员变量、方法参数、返回值中的可以看作直接朋友，否则出现在局部变量中的是间接朋友，也就是陌生人。

### 依赖倒置原则 (Dependency Inversion Principle, DIP)

高层模块不应该依赖低层模块，模块应依赖于抽象层，而不是具体实现。即应该面向接口编程，当一个对象与其他对象有依赖关系时，通过声明接口注入 (通过构造器或访问器) 不同的实现类实例来实现。  
每个底层实现类都应有接口或抽象类，且不应暴露接口或抽象类中未声明的方法。

### 组合/聚合复用原则 (Composite/Aggregate Reuse Principle, CARP)

尽量使用组合/聚合的方式，而不是通过继承达到复用的目的。

> [!note]  
> 单一职责原则、开闭原则、里氏代换原则、接口隔离原则、迪米特法则合称 **SOLID**。

---

## 23 种设计模式

> [!quote] 参考  
> - [图说设计模式 — Graphic Design Patterns (design-patterns.readthedocs.io)](https://design-patterns.readthedocs.io/zh_CN/latest/index.html)

### 创建型 (5 种)

#### 单例模式

保证一个类只有一个实例。  

#### 工厂方法模式

用于生产指定产品，简单工厂不满足开闭原则，工厂方法模式扩展会引入多个类。

#### 抽象工厂模式

用于生产某个产品族的全部产品，难以增加新产品，只能增加产品族。

#### 建造者模式

屏蔽了复杂对象的组建细节。

#### 原型模式

可以通过重写 `clone()` 方法、`序列化/反序列化` 来实现拷贝，需要注意浅拷贝和深拷贝。

### 结构型 (7 种)

#### 适配器模式

将一个类的接口转换为客户端希望的另一个接口，也称为包装器。  

#### 桥接模式

#### 装饰模式

#### 外观模式

#### 享元模式

#### 组合模式

#### 代理模式

### 行为型 (11 种)

#### 模板方法模式

#### 命令模式

#### 迭代器模式

#### 观察者模式

#### 中介者模式

#### 备忘录模式

#### 解释器模式

#### 状态模式

#### 策略模式

#### 责任链模式

#### 访问者模式
